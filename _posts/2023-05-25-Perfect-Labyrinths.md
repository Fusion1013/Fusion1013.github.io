---
layout: post
title: Generating Perfect Labyrinths
---

Many games use randomly generated labyrinths to automatically create challenges for players. An important aspect when procedurally generated labyrinths are used in games is that they must have a solution, the player can not be presented by an impossible task. This post will present three different methods for generating labyrinths with these properties, known as Perfect Labyrinths.

![_config.yml]({{ site.baseurl }}/images/DepthFirstSearchMaze.png)

## Method
A few of the methods described below make use of two graphs. One of the graphs is a Planar Graph, which represents all possible walls in the labyrinth. We call it 'G'. The other graph is the Dual to 'G', we call it 'G*'. The algorithms work by moving along 'G*' and removing edges in 'G' when these are crossed. The algorithm terminates once all nodes in G* have been visited at least once. Because the algorithms move from node to node along the edges of G*, the labyrinth generated must be perfect once the algorithm terminate, which means all nodes can be reached from any arbitrarily chosen starting node.

To create the entrance and exit of the maze we can simply remove two randomly chosen edges from the outer cycle of the graph. This method works since we have a perfect labyrinth. To ensure that the maze is not trivial to solve, a minimum distance between these edges can be introduced to prevent them from appearing next to each other.

### Aldous-Broder's Algorithm
Let us begin by taking a look at one of the simplest algorithms for creating a perfect labyrinth. This method makes use of a Spanning Tree to respresent the completed labyrinth. The algorithm begins by choosing a vertex in G* and making it the root of the tree. It then chooses a random edge of that node and moves along it. If the new node has not been visited, add it to the tree. This step is then repeated until all nodes in the graph have been visited.

The greatest advantage to this method is that it is simple to implement and generates labyrinths without obvious patterns.

![_config.yml]({{ site.baseurl }}/images/AldousMaze.png)

The greatest disadvantage is the time it takes to generate labyrinths for larger graphs. In its best case scenario, the algorithm has a complexity of O(n), where n is the number of nodes in G*. In its worst case it will never terminate.

Because of this, Aldous-Broder's algorithm is seldom practical to use, though it gives us an idea for where to start when designing better algorithms.

### Reverse Backtracking
The following algorithm works in a similar way to Aldous-Broder's, but with a few improvements. Like Aldous-Broder's it makes use of a Spanning Tree to represent the labyrinth. Unlike Aldous-Broder's, instead of selecting a node at random, it instead chooses an adjacent node that has not yet been visited. If no such nodes exist, backtrack along the path it has created until it reaches a node with unvisited neighbors. It then chooses one of those at random, and continues from there. With these simple improvements the algorithm prevents that the same node is visited multiple times. This gives it a complexity of O(n), which is the same as the best case for Aldous-Broder's algorithm. This algorithm is most often called Reverse Backtracking, or Randomized Depth-First Search.

![_config.yml]({{ site.baseurl }}/images/DepthFirstSearchMaze.png)

One disadvantage to Reverse Backtracking, which can be seen in the image above, is that it tends to generate long coridors without crossings, a problem that Aldous-Broder's algorithm does not have. Since both of these algorithms make use of Spanning Trees to represent the labyrinth, they will not contain any cycles, which might be desirable to create more difficult labyrinths.

### Randomized Prim's Algorithm
Randomized Prim's Algorithm presents a potential solution to the problem that Reverse Backtracking tends to produce long corridors. Prim's begins by randomly choosing a starting node in G* and adding its edges to a set. As long as there are walls in the set the algorithm performs the following steps:
* Randomly choose an edge from the set
* If only one of the nodes that the edge is connected to has been visited, do the following:
    - Mark the edge as a passage, and mark the unvisited node as a part of the maze.
    - Add the new nodes edges to the set.
* Remove the old edge from the set.

This algorithm produces labyrinths with multiple, shorter paths, like those generated by Aldous-Broder's algorithm. The downside being that it is more complicated to implement.

![_config.yml]({{ site.baseurl }}/images/PrimMaze.png)

## Discussion
We have now looked at a few different ways to randomly generate perfect labyrinths. We can see that the algorithms use similar methods to generate quite different results, in how the final labyrinth looks. With exception of Aldous-Broder's algorithm, none of the other algorithms can directly be seen as better or worse than the other. Since the difference is mostly in what the structure of the final labyrinth looks like, the choise is instead up to which result is the most desirable for the given application.

There are a few topics that I mentioned but didn't dive deeper into. For example; how could we generate labyrinths that contain cycles? What if we want to generate labyrinths that do not adhere to a grid? These are all topics for a future blog post however.